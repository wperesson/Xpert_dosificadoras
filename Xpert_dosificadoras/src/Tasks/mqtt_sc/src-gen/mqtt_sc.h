/** Generated by YAKINDU Statechart Tools code generator. */

#ifndef MQTT_SC_H_
#define MQTT_SC_H_

#ifdef __cplusplus
extern "C" { 
#endif

/*!
* Forward declaration for the Mqtt_sc state machine.
*/
typedef struct Mqtt_sc Mqtt_sc;

/*!
* Forward declaration of the data structure for the Mqtt_scIface interface scope.
*/
typedef struct Mqtt_scIface Mqtt_scIface;

#ifdef __cplusplus
}
#endif

#include "..\src\sc_types.h"

#ifdef __cplusplus
extern "C" { 
#endif 

/*! \file Header of the state machine 'mqtt_sc'.
*/

#ifndef MQTT_SC_EVENTQUEUE_BUFFERSIZE
#define MQTT_SC_EVENTQUEUE_BUFFERSIZE 20
#endif
#ifndef MQTT_SC_IN_EVENTQUEUE_BUFFERSIZE
#define MQTT_SC_IN_EVENTQUEUE_BUFFERSIZE MQTT_SC_EVENTQUEUE_BUFFERSIZE
#endif
#ifndef SC_INVALID_EVENT_VALUE
#define SC_INVALID_EVENT_VALUE 0
#endif
/*! Define number of states in the state enum */
#define MQTT_SC_STATE_COUNT 6

/*! Define dimension of the state configuration vector for orthogonal states. */
#define MQTT_SC_MAX_ORTHOGONAL_STATES 1

/*! Define indices of states in the StateConfVector */
#define SCVI_MQTT_SC_R1_GPRS_OFF 0
#define SCVI_MQTT_SC_R1_GPRS_ON 0
#define SCVI_MQTT_SC_R1_GPRS_ON_R1_NOT_CONN 0
#define SCVI_MQTT_SC_R1_GPRS_ON_R1_CONNECTED 0
#define SCVI_MQTT_SC_R1_GPRS_ON_R1_CONNECTED_R2_CONN_TO_BROKER 0
#define SCVI_MQTT_SC_R1_GPRS_ON_R1_CONNECTED_R2_CREDENTIALS 0


/*
 * Enum of event names in the statechart.
 */
typedef enum  {
	Mqtt_sc_invalid_event = SC_INVALID_EVENT_VALUE,
	Mqtt_sc_conn_to_op,
	Mqtt_sc_gprs_on,
	Mqtt_sc_cred_rcv,
	Mqtt_sc_publish_var,
	Mqtt_sc_publish_id,
	Mqtt_sc_publish_sett
} Mqtt_scEventID;

/*
 * Struct that represents a single event.
 */
typedef struct {
	Mqtt_scEventID name;
} mqtt_sc_event;

/*
 * Queue that holds the raised events.
 */
typedef struct mqtt_sc_eventqueue_s {
	mqtt_sc_event *events;
	sc_integer capacity;
	sc_integer pop_index;
	sc_integer push_index;
	sc_integer size;
} mqtt_sc_eventqueue;

/*! Enumeration of all states */ 
typedef enum
{
	Mqtt_sc_last_state,
	Mqtt_sc_r1_GPRS_OFF,
	Mqtt_sc_r1_GPRS_ON,
	Mqtt_sc_r1_GPRS_ON_r1_Not_conn,
	Mqtt_sc_r1_GPRS_ON_r1_Connected,
	Mqtt_sc_r1_GPRS_ON_r1_Connected_r2_conn_to_broker,
	Mqtt_sc_r1_GPRS_ON_r1_Connected_r2_credentials
} Mqtt_scStates;


/*! Type declaration of the data structure for the Mqtt_scIface interface scope. */
struct Mqtt_scIface
{
	sc_boolean conn_to_op_raised;
	sc_boolean gprs_on_raised;
	sc_boolean cred_rcv_raised;
	sc_boolean publish_var_raised;
	sc_boolean publish_id_raised;
	sc_boolean publish_sett_raised;
};






/*! 
 * Type declaration of the data structure for the Mqtt_sc state machine.
 * This data structure has to be allocated by the client code. 
 */
struct Mqtt_sc
{
	Mqtt_scStates stateConfVector[MQTT_SC_MAX_ORTHOGONAL_STATES];
	sc_ushort stateConfVectorPosition; 
	Mqtt_scIface iface;
	sc_boolean isExecuting;
	mqtt_sc_eventqueue in_event_queue;
	mqtt_sc_event in_buffer[MQTT_SC_IN_EVENTQUEUE_BUFFERSIZE];
};



/*! Initializes the Mqtt_sc state machine data structures. Must be called before first usage.*/
extern void mqtt_sc_init(Mqtt_sc* handle);


/*! Activates the state machine. */
extern void mqtt_sc_enter(Mqtt_sc* handle);

/*! Deactivates the state machine. */
extern void mqtt_sc_exit(Mqtt_sc* handle);




/*! Raises the in event 'conn_to_op' that is defined in the default interface scope. */ 
extern void mqtt_sc_raise_conn_to_op(Mqtt_sc* handle);
/*! Raises the in event 'gprs_on' that is defined in the default interface scope. */ 
extern void mqtt_sc_raise_gprs_on(Mqtt_sc* handle);
/*! Raises the in event 'cred_rcv' that is defined in the default interface scope. */ 
extern void mqtt_sc_raise_cred_rcv(Mqtt_sc* handle);
/*! Raises the in event 'publish_var' that is defined in the default interface scope. */ 
extern void mqtt_sc_raise_publish_var(Mqtt_sc* handle);
/*! Raises the in event 'publish_id' that is defined in the default interface scope. */ 
extern void mqtt_sc_raise_publish_id(Mqtt_sc* handle);
/*! Raises the in event 'publish_sett' that is defined in the default interface scope. */ 
extern void mqtt_sc_raise_publish_sett(Mqtt_sc* handle);

/*!
 * Checks whether the state machine is active (until 2.4.1 this method was used for states).
 * A state machine is active if it was entered. It is inactive if it has not been entered at all or if it has been exited.
 */
extern sc_boolean mqtt_sc_is_active(const Mqtt_sc* handle);

/*!
 * Checks if all active states are final. 
 * If there are no active states then the state machine is considered being inactive. In this case this method returns false.
 */
extern sc_boolean mqtt_sc_is_final(const Mqtt_sc* handle);

/*! Checks if the specified state is active (until 2.4.1 the used method for states was called isActive()). */
extern sc_boolean mqtt_sc_is_state_active(const Mqtt_sc* handle, Mqtt_scStates state);


#ifdef __cplusplus
}
#endif 

#endif /* MQTT_SC_H_ */
